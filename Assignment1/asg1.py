# -*- coding: utf-8 -*-
"""Asg1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NQa-j6lySQItiBpEsdxgTWEulgnw6dg3
"""

#Problem 1 - Solved

#Input
n = int(input())

#Character
s='*'

#For loop with output
for i in range(n):
  print((s*i).rjust(n-1)+s+(s*i).ljust(n-1))

#Test Case:5

#Problem 2 

#Think smarter not harder -- saves memory this way
a = 1
b = 2
c = 0
print(a)
print(b)

#For loop for increasing pell numbers
#builds upon each other
for i in range(12):
  c = a + 2*b
  a = b
  b = c 
  print(c)

#Test Case: N/A just start program

# Problem 3 

#Function
def countPairs(n) : 
    count = 0
  
    # Check for each number 1 to sqrt(c) from user input
    for i in range(1, int(n**0.5) + 1) : 
    
        #sq of i (A or B value)
        sq = i * i 
  
        #subtract A or B from c 
        dif = n - sq 
 
        #is it a perfect sq (dif)  
        sqrtDiff = int(dif**0.5) 
  
        #if yes, increase count 
        if sqrtDif * sqrtDif == dif : 
            count += 1
  
    return count

#Driver
if __name__ == "__main__" : 
  
   
  c = int(input()) 

  #count return   
  if countPairs(c) == 0:
    print("False")
  else:
    print("True")

#Test Case: 5 - True / 3 - False / 2 - True / 1 - True

# Problem 4 

#Input - list
list_v = list(map(int, input().split(',')))

#Input - k value
k = int(input())

count = 0

#Sorts it to prevent duplicated pairs
list_v.sort()

#Looks at index to check out what pairs match k
next_index = 0
current_index = 0

#While loop that compares current i to next i
while current_index < len(listA):
   if list_v[current_index] - list_v[next_index] == k:
      count += 1
      next_index += 1
      current_index += 1

   elif list_v[current_index] - list_v[next_index] > k:
      next_index += 1
   else:
      current_index += 1
#Output
print(count)

#Test Case: [3, 1, 4, 1, 5], k = 2 / output = 2

# Problem 5 

#Function
def unique_emails(emails):

    new = set()                                      
    
    for email in emails:                             
        
        #Access local section 
        local, domain = email.split("@")             
        
        if "+" in local:                             
            
            #ignore everything after the plus sign
            local = local[:local.index("+")]   

        #ignore '.'
        new.add(local.replace('.','') + "@" + domain) 

    return len(new)                                  


# Driver- input and output
emails1 = list(map(str, input().split(',')))
print(unique_emails(emails1))

# Problem 6 

#Function
def dest_city(paths):
    return (set(path[1] for path in paths)- set(path[0] for path in paths)).pop()

# test cases
#uncomment out which test case you would like to use and its corresponding print statement
paths1 = [["B","C"],["D","B"],["C","A"]]
#paths2 = [["London", "New York"], ["New York","Tampa"], ["Delhi","London"]]
print(dest_city(paths1))
#print(dest_city(paths2))